/*
 This file belongs to the Servoy development and deployment environment, Copyright (C) 1997-2010 Servoy BV

 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation; either version 3 of the License, or (at your option) any
 later version.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.

 You should have received a copy of the GNU Affero General Public License along
 with this program; if not, see http://www.gnu.org/licenses or write to the Free
 Software Foundation,Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301
 */
package com.servoy.eclipse.ui.property;

import java.util.ArrayList;
import java.util.List;

import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.jface.viewers.CellEditor;
import org.eclipse.jface.viewers.ILabelProvider;
import org.eclipse.jface.viewers.LabelProvider;
import org.eclipse.jface.viewers.TextCellEditor;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Control;
import org.eclipse.ui.views.properties.IPropertyDescriptor;

import com.servoy.eclipse.model.util.ModelUtils;
import com.servoy.eclipse.ui.dialogs.MethodDialog.MethodListOptions;
import com.servoy.eclipse.ui.editors.IValueEditor;
import com.servoy.eclipse.ui.editors.MethodCellEditor;
import com.servoy.eclipse.ui.labelproviders.AccesCheckingContextDelegateLabelProvider;
import com.servoy.eclipse.ui.labelproviders.FormContextDelegateLabelProvider;
import com.servoy.eclipse.ui.labelproviders.MethodLabelProvider;
import com.servoy.eclipse.ui.labelproviders.SolutionContextDelegateLabelProvider;
import com.servoy.eclipse.ui.util.EditorUtil;
import com.servoy.eclipse.ui.views.solutionexplorer.actions.NewMethodAction;
import com.servoy.j2db.persistence.AbstractBase;
import com.servoy.j2db.persistence.ArgumentType;
import com.servoy.j2db.persistence.Form;
import com.servoy.j2db.persistence.IPersist;
import com.servoy.j2db.persistence.IRepository;
import com.servoy.j2db.persistence.IScriptProvider;
import com.servoy.j2db.persistence.ISupportExtendsID;
import com.servoy.j2db.persistence.ITable;
import com.servoy.j2db.persistence.MethodArgument;
import com.servoy.j2db.persistence.MethodTemplate;
import com.servoy.j2db.util.Pair;
import com.servoy.j2db.util.PersistHelper;
import com.servoy.j2db.util.SafeArrayList;
import com.servoy.j2db.util.Utils;

/**
 * Property controller for method properties, subproperties are instance arguments
 *
 * @author rgansevles
 *
 */
public class MethodPropertyController<P> extends PropertyController<P, Object> implements IPropertySetter<P, ISetterAwarePropertySource>
{
	private final PersistContext persistContext;
	private final MethodListOptions options;


	public MethodPropertyController(Object id, String displayName, PersistContext persistContext, MethodListOptions options)
	{
		super(id, displayName);
		this.options = options;
		this.persistContext = persistContext;
		setLabelProvider(new AccesCheckingContextDelegateLabelProvider(new SolutionContextDelegateLabelProvider(
			new FormContextDelegateLabelProvider(new MethodLabelProvider(persistContext, true, !options.includeDefault), persistContext.getContext()))));
		setSupportsReadonly(true);
	}

	@Override
	public CellEditor createPropertyEditor(Composite parent)
	{
		ILabelProvider methodLabelProvider = new AccesCheckingContextDelegateLabelProvider(
			new FormContextDelegateLabelProvider(new MethodLabelProvider(persistContext, false, !options.includeDefault), persistContext.getContext()));
		return new MethodCellEditor(parent, methodLabelProvider, new MethodValueEditor(persistContext), persistContext, getId(), false, // readonly is handled in openDialogBox below
			options)
		{
			@Override
			public MethodWithArguments openDialogBox(Control cellEditorWindow)
			{
				if (MethodPropertyController.this.isReadOnly())
				{
					MethodWithArguments val = (MethodWithArguments)getValue();
					if (persistContext.getContext() instanceof Form)
					{
						// val.methodId is the id of the actual called method according to form inheritance (generated by FormInheritenceMethodConverter)
						IScriptProvider scriptMethod = ModelUtils.getScriptMethod(persistContext.getPersist(), persistContext.getContext(), val.table,
							val.methodUUID);
						if (scriptMethod != null && !scriptMethod.getParent().getUUID().equals(persistContext.getContext().getUUID()) &&
							scriptMethod.getParent() instanceof Form &&
							MessageDialog.openQuestion(getControl().getShell(), "Method property of a super form", "Overwrite it with a method in this form?"))
						{
							// the context is the currently viewed form
							NewMethodAction.createNewMethod(getControl().getShell(), persistContext.getContext(), getId().toString(), true,
								scriptMethod.getName(), null, null);
							// Note: the original value is returned, but FormInheritenceMethodConverter.getScriptMethod() will find
							// the new method via the form hierarchy
						}
					}
					// must always return original value (readonly)
					return val;
				}
				return super.openDialogBox(cellEditorWindow);
			}
		};
	}

	public static IPropertyDescriptor[] createMethodPropertyDescriptors(IScriptProvider scriptMethod, final PersistContext context, final String methodKey)
	{
		if (!(scriptMethod instanceof AbstractBase))
		{
			return new IPropertyDescriptor[0];
		}
		List<IPropertyDescriptor> descs = new ArrayList<IPropertyDescriptor>();

		final MethodArgument[] formalArguments = ((AbstractBase)scriptMethod).getRuntimeProperty(IScriptProvider.METHOD_ARGUMENTS);
		MethodArgument[] combinedArguments = getCombinedParams(formalArguments, context.getPersist(), scriptMethod, methodKey);
		final MethodTemplate template = MethodTemplate.getTemplate(scriptMethod.getClass(), methodKey);
		final int nargs = combinedArguments != null && (template.getArguments() == null || combinedArguments.length > template.getArguments().length)
			? combinedArguments.length : ((template.getArguments() == null) ? 0 : template.getArguments().length);
		for (int i = 0; i < nargs; i++)
		{
			PropertyController<String, String> propertyController;
			if (template.getArguments() != null && template.getArguments().length > i)
			{
				// arguments defined in template, will be overridden at runtime
				final MethodArgument templateArgument = template.getArguments()[i];
				String argName = (combinedArguments != null && i < combinedArguments.length) ? combinedArguments[i].getName() : "arguments[" + i + ']';
				propertyController = new PropertyController<String, String>(Integer.valueOf(i), argName, null, new LabelProvider()
				{
					@Override
					public String getText(Object element)
					{
						return templateArgument.getName() + " {" + templateArgument.getType() + '}';
					}
				}, null);
				propertyController.setDescription(templateArgument.getDescription());
			}
			else
			{
				final int index = i;
				propertyController = new PropertyController<String, String>(Integer.valueOf(i), combinedArguments[i].getName(), null, new LabelProvider()
				{
					@Override
					public String getText(Object element)
					{
						if (element == null || "".equals(element))
						{
							// argument is not set in method call in subform, show inherited value
							Form contextForm = (Form)context.getContext().getAncestor(IRepository.FORMS);
							if (contextForm != null)
							{
								List<Form> formHierarchy = ModelUtils.getEditingFlattenedSolution(context.getContext()).getFormHierarchy(contextForm);
								for (Form form : formHierarchy)
								{
									List<Object> instanceMethodArguments = form.getFlattenedMethodArguments(methodKey);
									if (instanceMethodArguments != null && instanceMethodArguments.size() > index)
									{
										Object inherited = instanceMethodArguments.get(index);
										if (inherited != null)
										{
											return inherited.toString() + " [" + form.getName() + ']';
										}
									}
								}
							}
						}
						return super.getText(element);
					}
				}, new ICellEditorFactory()
				{
					public CellEditor createPropertyEditor(Composite parent)
					{
						if (nargs > formalArguments.length)
						{
							return new TextAndButtonCellEditor(parent);
						}
						else
						{
							return new TextCellEditor(parent);
						}
					}
				});
			}
			descs.add(propertyController);
		}
		return descs.toArray(new IPropertyDescriptor[descs.size()]);
	}

	/**
	 * Returns the combined instance parameters (from the frm File) with the actual formal parameters in the function deffinition
	 * Adds  when a name mismatch at position i happens the display name in the properties view will be  formalName (previewsName)
	 */
	private static MethodArgument[] getCombinedParams(MethodArgument[] formalArguments, IPersist context, IScriptProvider scriptMethod, String methodKey)
	{
		if (formalArguments == null) return null;
		ArrayList<MethodArgument> finalParamsList = new ArrayList<MethodArgument>(); // the returned computed list
		Pair<List<String>, List<Object>> instanceParamsArgs = ((AbstractBase)context).getFlattenedMethodParameters(methodKey);
		List<String> persistParamNames = instanceParamsArgs.getLeft() != null ? instanceParamsArgs.getLeft() : new ArrayList<String>();
		List<Object> actualArguments = instanceParamsArgs.getRight() != null ? instanceParamsArgs.getRight() : new ArrayList<Object>();

		for (int i = 0; i < formalArguments.length; i++)
		{
			MethodArgument methodArgument = formalArguments[i];
			Object persistParamName = persistParamNames.size() > i ? persistParamNames.get(i) : "";
			if (persistParamNames.size() > i && !methodArgument.getName().equals(persistParamName) && !methodArgument.getName().contains("("))
			{
				finalParamsList.add(
					new MethodArgument(methodArgument.getName() + " (" + persistParamName + ")", methodArgument.getType(), methodArgument.getDescription()));
			}
			else
			{
				finalParamsList.add(methodArgument);
			}
		}
		// add used extra arguments not present in the formal parameter list
		if (formalArguments.length < actualArguments.size())
		{
			for (int i = formalArguments.length; i < actualArguments.size(); i++)
			{
				String missingText = "-missing-";
				if (i < persistParamNames.size())
				{
					missingText += " (" + persistParamNames.get(i) + ")";
				}
				finalParamsList.add(new MethodArgument(missingText, ArgumentType.Object, null));
			}
		}
		return finalParamsList.toArray(new MethodArgument[finalParamsList.size()]);//Utils.arrayJoin(formalArguments, paramsList.toArray());
	}

	public static void setMethodArguments(IPersist persist, Object id, List<String> paramNames, List<Object> arguments)
	{
		if (persist instanceof AbstractBase)
		{
			int len = 0;
			for (int i = 0; arguments != null && i < arguments.size(); i++)
			{
				// find the index of the last non-null entry
				if (arguments.get(i) != null) len = i + 1;
			}

			if (arguments != null && arguments.size() > 0 && (paramNames.size() != arguments.size()))
			{
				//forms can be without new parameter Names if they updated before the parameter names array was introduced
				((AbstractBase)persist).putMethodArguments(id.toString(), new ArrayList<Object>(arguments.subList(0, len)));
			}
			else
			{
				// save a copy of the mwa.arguments list so that changes in mwa.arguments are not affecting customProperties
				((AbstractBase)persist).putMethodParameters(id.toString(), len == 0 ? null : paramNames.subList(0, len),
					len == 0 ? null : new ArrayList<Object>(arguments.subList(0, len)));
			}
		}
	}


	public static class MethodValueEditor implements IValueEditor<MethodWithArguments>
	{
		private final PersistContext persistContext;

		public MethodValueEditor(PersistContext persistContext)
		{
			this.persistContext = persistContext;
		}

		public boolean canEdit(MethodWithArguments value)
		{
			return ModelUtils.getScriptMethod(persistContext.getPersist(), persistContext.getContext(), value.table, value.methodUUID) != null;
		}

		public void openEditor(MethodWithArguments value)
		{
			EditorUtil.openScriptEditor(ModelUtils.getScriptMethod(persistContext.getPersist(), persistContext.getContext(), value.table, value.methodUUID),
				null,
				true);
		}
	}


	public static class MethodPropertySource extends ComplexPropertySourceWithStandardReset<MethodWithArguments>
	{
		public static final String DELETED_ARGUMENT = "-DELETED-ARGUMENT-";

		private IPropertyDescriptor[] propertyDescriptors = null;
		private final PersistContext persistContext;
		private final String methodKey;
		private final ITable table;

		public MethodPropertySource(ComplexProperty<MethodWithArguments> complexProperty, PersistContext persistContext, ITable table, String methodKey,
			boolean readOnly)
		{
			super(complexProperty);
			this.persistContext = persistContext;
			this.table = table;
			this.methodKey = methodKey;
			setReadonly(readOnly);
		}

		@Override
		public IPropertyDescriptor[] createPropertyDescriptors()
		{
			if (propertyDescriptors == null)
			{
				MethodWithArguments mwa = getEditableValue();
				if (mwa == null)
				{
					return new IPropertyDescriptor[0];
				}

				String methodUUID;
				IPersist persist = persistContext.getPersist();
				if (MethodWithArguments.METHOD_DEFAULT.equals(mwa) && persist instanceof Form && ((Form)persist).getExtendsID() != null)
				{
					// look for method in superform
					Form flattenedForm = ModelUtils.getEditingFlattenedSolution(persist).getFlattenedForm(persist);
					Object propertyValue = PersistPropertySource.createPersistPropertySource(flattenedForm, null, false).getPropertyValue(methodKey);
					methodUUID = ((ComplexProperty<MethodWithArguments>)propertyValue).getValue().methodUUID;
				}
				else
				{
					methodUUID = mwa.methodUUID;
				}
				IScriptProvider scriptMethod = ModelUtils.getScriptMethod(persistContext.getPersist(), persistContext.getContext(), table, methodUUID);
				// make sure sub-properties are sorted in defined order
				propertyDescriptors = PropertyController.applySequencePropertyComparator(
					createMethodPropertyDescriptors(scriptMethod, persistContext, methodKey));
			}
			return propertyDescriptors;
		}


		@Override
		public Object getPropertyValue(Object id)
		{
			int idx = ((Integer)id).intValue();
			MethodWithArguments mwa = getEditableValue();
			if (mwa.arguments == null || idx < 0 || idx >= mwa.arguments.size() || mwa.arguments.get(idx) == null)
			{
				return "";
			}
			return mwa.arguments.get(idx);
		}

		@Override
		protected MethodWithArguments setComplexPropertyValue(Object id, Object v)
		{
			int idx = ((Integer)id).intValue();
			MethodWithArguments mwa = getEditableValue();
			if (mwa.arguments == null)
			{
				mwa = new MethodWithArguments(mwa.methodUUID, new SafeArrayList<String>(), new SafeArrayList<Object>(), mwa.table);
			}
			boolean delete = false;
			String value;
			if (DELETED_ARGUMENT.equals(v))
			{
				value = null;
				delete = true;
			}
			else if (v instanceof String && ((String)v).length() > 0)
			{
				Object parsed = Utils.parseJSExpression(v);
				if (parsed == null)
				{
					// not a bool, number or string, convert to quoted string
					value = Utils.makeJSExpression(v);
				}
				else
				{
					value = (String)v;
				}
			}
			else
			{
				value = null;
			}

			{
				IScriptProvider scriptMethod = ModelUtils.getScriptMethod(persistContext.getPersist(), persistContext.getContext(), mwa.table, mwa.methodUUID);
				MethodArgument[] formalArguments = ((AbstractBase)scriptMethod).getRuntimeProperty(IScriptProvider.METHOD_ARGUMENTS);

				if (!delete && idx < formalArguments.length)
				{
					mwa.arguments.set(idx, value);
					for (int i = 0; i < formalArguments.length && idx < formalArguments.length; i++)
					{
						mwa.paramNames.set(i, formalArguments[i].getName());
					}
					// one edit by the user should make the props view valid with current jsfunction signature
					// clear the rest of the missing args
					if (idx < formalArguments.length)
					{
						for (int i = formalArguments.length; i < mwa.arguments.size(); i++)
						{
							mwa.arguments.set(i, null);
						}
					}
				}
				else
				{ // delete was pressed on a missing argument , shift the missing arguments up
					mwa.arguments.remove(idx);
					if (mwa.arguments.size() < mwa.paramNames.size()) mwa.paramNames.remove(idx);
					// if they now are in sync, make sure the names line up
					if (formalArguments.length == mwa.paramNames.size())
					{
						for (int i = 0; i < formalArguments.length; i++)
						{
							mwa.paramNames.set(i, formalArguments[i].getName());
						}
					}
				}
			}
			return mwa;
		}

		@Override
		public Object resetComplexPropertyValue(Object id)
		{
			Object resetToValue = super.resetComplexPropertyValue(id); // basically null

			// if the element extends another element in super form - reset to the value super element has for that param name if possible
			if (id instanceof Integer)
			{
				IPersist persist = persistContext.getPersist();
				if (persist instanceof ISupportExtendsID)
				{
					persist = PersistHelper.getSuperPersist((ISupportExtendsID)persist);

					if (persist != null) // parent persist
					{
						int idx = ((Integer)id).intValue();
						String paramName = null;
						// it's the index in the parameters list; find the one from extended persist if applicable and revert to that
						MethodWithArguments mwa = getEditableValue();
						if (mwa.paramNames != null && mwa.paramNames.size() > idx) paramName = mwa.paramNames.get(idx);

						Pair<List<String>, List<Object>> superMethodParams = ((AbstractBase)persist).getFlattenedMethodParameters(methodKey);

						if (paramName != null)
						{
							// search by param name; newer persists will always have param names stored as well; older ones might only have values stored
							int searchIdx = superMethodParams.getLeft().indexOf(paramName);
							if (searchIdx >= 0) idx = searchIdx;
						}

						List<Object> superParamValues = superMethodParams.getRight();
						if (superParamValues != null && superParamValues.size() > idx) resetToValue = superParamValues.get(idx);
					}
				}
			}

			return resetToValue;
		}

	}


	// IPropertySetter is implemented just for resetting a value - which also needs to reset the method arguments;
	// the other methods of the interface are just forwarding the call to default given property source handling
	@Override
	public void setProperty(ISetterAwarePropertySource propertySource, P value)
	{
		propertySource.defaultSetProperty(getId(), value);
	}

	@Override
	public P getProperty(ISetterAwarePropertySource propertySource)
	{
		return (P)propertySource.defaultGetProperty(getId());
	}

	@Override
	public boolean isPropertySet(ISetterAwarePropertySource propertySource)
	{
		return propertySource.defaultIsPropertySet(getId());
	}

	@Override
	public void resetPropertyValue(ISetterAwarePropertySource propertySource)
	{
		// reset method arguments as well
		((AbstractBase)persistContext.getPersist()).clearMethodParameters(getId().toString());
		propertySource.defaultResetProperty(getId());
	}

}
