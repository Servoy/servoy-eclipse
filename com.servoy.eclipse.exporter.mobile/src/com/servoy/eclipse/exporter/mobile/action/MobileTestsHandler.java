/*
 This file belongs to the Servoy development and deployment environment, Copyright (C) 1997-2013 Servoy BV

 This program is free software; you can redistribute it and/or modify it under
 the terms of the GNU Affero General Public License as published by the Free
 Software Foundation; either version 3 of the License, or (at your option) any
 later version.

 This program is distributed in the hope that it will be useful, but WITHOUT
 ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.

 You should have received a copy of the GNU Affero General Public License along
 with this program; if not, see http://www.gnu.org/licenses or write to the Free
 Software Foundation,Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301
 */

package com.servoy.eclipse.exporter.mobile.action;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;

import org.eclipse.core.commands.AbstractHandler;
import org.eclipse.core.commands.ExecutionEvent;
import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.Platform;
import org.eclipse.debug.core.ILaunchConfiguration;
import org.eclipse.debug.core.ILaunchConfigurationWorkingCopy;
import org.eclipse.debug.core.ILaunchManager;
import org.eclipse.debug.ui.DebugUITools;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.handlers.HandlerUtil;

import com.servoy.eclipse.core.ServoyModelManager;
import com.servoy.eclipse.core.util.UIUtils;
import com.servoy.eclipse.exporter.mobile.launch.IMobileLaunchConstants;
import com.servoy.eclipse.exporter.mobile.launch.test.IMobileTestLaunchConstants;
import com.servoy.eclipse.jsunit.SolutionUnitTestTarget;
import com.servoy.eclipse.jsunit.launch.JSUnitLaunchConfigurationDelegate;
import com.servoy.eclipse.jsunit.runner.TestTarget;
import com.servoy.eclipse.model.nature.ServoyProject;
import com.servoy.eclipse.model.util.ServoyLog;

/**
 * Action that will run mobile unit tests using a launchConfiguration for a given TestTarget.
 * It will try to reuse an existing launch configuration if possible.
 * 
 * @author acostescu
 */
public abstract class MobileTestsHandler extends AbstractHandler
{

	private static final int MAX_AUTO_CONFIG_INSTANCES = 10;

	private final boolean noDebug;
	private Shell shell;

	public MobileTestsHandler(boolean noDebug)
	{
		this.noDebug = noDebug;
	}

	@Override
	public Object execute(ExecutionEvent event) throws ExecutionException
	{
		// find an existing launch configuration and reuse it if possible;
		// otherwise create a new - default launch configuration that uses this test target & make sure no more then 10 such auto-generated
		// configurations exist...
		TestTarget target = getTestTarget(HandlerUtil.getActiveWorkbenchWindow(event).getActivePage().getSelection());
		ServoyProject activeProject = ServoyModelManager.getServoyModelManager().getServoyModel().getActiveProject();

		ILaunchConfiguration configuration = findLaunchConfiguration(target, activeProject);
		if (configuration != null) DebugUITools.launch(configuration, ILaunchManager.RUN_MODE);
		return null;
	}

	public ILaunchConfiguration findLaunchConfiguration(TestTarget target, ServoyProject activeProject)
	{
		if (target == null)
		{
			// use currently active solution
			target = new TestTarget(activeProject.getSolution());
		}

		ILaunchConfiguration configToUse = null;
		String targetAsString = target.convertToString();

		ArrayList<ILaunchConfiguration> compatibleConfigs = new ArrayList<ILaunchConfiguration>();
		ArrayList<ILaunchConfiguration> allConfigs = new ArrayList<ILaunchConfiguration>();
		try
		{
			ILaunchConfiguration[] cfgs = StartMobileClientActionDelegate.getLaunchConfigsForProject(activeProject, true,
				IMobileTestLaunchConstants.LAUNCH_TEST_CONFIGURATION_TYPE_ID);
			addCompatible(targetAsString, cfgs, compatibleConfigs);
			allConfigs.addAll(Arrays.asList(cfgs));

			cfgs = StartMobileClientActionDelegate.getLaunchConfigsForProject(activeProject, false,
				IMobileTestLaunchConstants.LAUNCH_TEST_CONFIGURATION_TYPE_ID);
			addCompatible(targetAsString, cfgs, compatibleConfigs);
			allConfigs.addAll(Arrays.asList(cfgs));

			if (compatibleConfigs.size() < 1)
			{
				// create a default config for this target; mark it as auto-generated
				int latestIdx = investigateAutoGeneratedConfigurations(allConfigs, true);

				configToUse = StartMobileClientActionDelegate.createDefaultLaunchConfig(
					activeProject,
					noDebug,
					IMobileTestLaunchConstants.LAUNCH_TEST_CONFIGURATION_TYPE_ID,
					StartMobileClientActionDelegate.getDefaultConfigName(activeProject.getSolution().getName(),
						IMobileTestLaunchConstants.LAUNCH_TEST_CONFIGURATION_TYPE_ID, noDebug) +
						" (" +
						JSUnitLaunchConfigurationDelegate.generateLaunchConfigName(target) + ")");
				ILaunchConfigurationWorkingCopy wc = configToUse.getWorkingCopy();
				wc.setAttribute(JSUnitLaunchConfigurationDelegate.LAUNCH_CONFIG_INSTANCE, target.convertToString());
				wc.setAttribute(IMobileTestLaunchConstants.AUTO_GENERATED, String.valueOf(latestIdx + 1));
				configToUse = wc.doSave();
			}
			else if (compatibleConfigs.size() > 1)
			{
				// user should be able to choose the one he wants
				if (shell == null) shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();
				Collections.sort(compatibleConfigs, new Comparator<ILaunchConfiguration>()
				{
					@Override
					public int compare(ILaunchConfiguration o1, ILaunchConfiguration o2)
					{
						return o1.getName().compareToIgnoreCase(o2.getName());
					}
				});
				String[] options = new String[compatibleConfigs.size()];
				for (int i = compatibleConfigs.size() - 1; i >= 0; i--)
					options[i] = compatibleConfigs.get(i).getName();
				int choice = UIUtils.showOptionDialog(shell, "Please choose a launch configuration",
					"Multiple launch configurations found for the targeted tests:", options, 0);

				if (choice != -1)
				{
					// user did not choose to cancel
					configToUse = updateLatestUseIfAutoGenerated(compatibleConfigs.get(choice), allConfigs);
				}
			}
			else
			{
				configToUse = updateLatestUseIfAutoGenerated(compatibleConfigs.get(0), allConfigs);
			}
		}
		catch (CoreException e)
		{
			ServoyLog.logError(e);
		}
		return configToUse;
	}

	private ILaunchConfiguration updateLatestUseIfAutoGenerated(ILaunchConfiguration configToUse, ArrayList<ILaunchConfiguration> allConfigs)
		throws CoreException
	{
		if (configToUse.hasAttribute(IMobileTestLaunchConstants.AUTO_GENERATED))
		{
			// update it's latest usage
			ILaunchConfigurationWorkingCopy wc = configToUse.getWorkingCopy();
			wc.setAttribute(IMobileTestLaunchConstants.AUTO_GENERATED, String.valueOf(investigateAutoGeneratedConfigurations(allConfigs, false) + 1));
			configToUse = wc.doSave();
		}
		return configToUse;
	}

	/**
	 * @return the highest value of IMobileTestLaunchConstants.AUTO_GENERATED in remaining auto-generated configs.
	 */
	private int investigateAutoGeneratedConfigurations(ArrayList<ILaunchConfiguration> allConfigs, boolean limit) throws CoreException
	{
		ArrayList<ILaunchConfiguration> autoGenerated = new ArrayList<ILaunchConfiguration>();

		for (ILaunchConfiguration c : allConfigs)
		{
			if (c.hasAttribute(IMobileTestLaunchConstants.AUTO_GENERATED)) autoGenerated.add(c);
		}

		Collections.sort(autoGenerated, new Comparator<ILaunchConfiguration>()
		{
			@Override
			public int compare(ILaunchConfiguration c1, ILaunchConfiguration c2)
			{
				// last used first sort 
				try
				{
					return Integer.parseInt(c2.getAttribute(IMobileTestLaunchConstants.AUTO_GENERATED, "0")) -
						Integer.parseInt(c1.getAttribute(IMobileTestLaunchConstants.AUTO_GENERATED, "0"));
				}
				catch (CoreException e)
				{
					throw new RuntimeException(e);
				}
			}
		});

		int last;
		if (autoGenerated.size() >= MAX_AUTO_CONFIG_INSTANCES)
		{
			last = MAX_AUTO_CONFIG_INSTANCES - 2;
			for (int i = last + 1; i < autoGenerated.size(); i++)
			{
				autoGenerated.get(i).delete();
			}
		}
		else
		{
			last = autoGenerated.size() - 1;
		}
		return (last >= 0) ? Integer.parseInt(autoGenerated.get(last).getAttribute(IMobileTestLaunchConstants.AUTO_GENERATED, "0")) : 0;
	}

	private void addCompatible(String targetAsString, ILaunchConfiguration[] available, ArrayList<ILaunchConfiguration> configs) throws CoreException
	{
		for (ILaunchConfiguration c : available)
		{
			if (Boolean.parseBoolean(c.getAttribute(IMobileLaunchConstants.NODEBUG, "true")) == noDebug &&
				targetAsString.equals(c.getAttribute(JSUnitLaunchConfigurationDelegate.LAUNCH_CONFIG_INSTANCE,
					TestTarget.activeProjectTarget().convertToString())))
			{
				configs.add(c);
			}
		}
	}

	protected TestTarget getTestTarget(ISelection iSelection)
	{
		if (iSelection instanceof IStructuredSelection)
		{
			IStructuredSelection structuredSelection = (IStructuredSelection)iSelection;
			if (structuredSelection != null)
			{
				if (structuredSelection.size() == 1)
				{
					Object fe = Platform.getAdapterManager().getAdapter(structuredSelection.getFirstElement(), SolutionUnitTestTarget.class);
					if (fe != null)
					{
						return ((SolutionUnitTestTarget)fe).getTestTarget();
					}
				}
			}
		}
		return null;
	}

}